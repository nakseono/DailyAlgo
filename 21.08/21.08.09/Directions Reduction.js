// 옛날 옛적에, 오래된 거친 산지 서쪽을 지나던 길에
// 한 남성에게 한 지점에서 다른 지점으로 이동하라는 지침이 주어졌습니다.
// 방향은 "북쪽", "남쪽", "서쪽", "동쪽"이었다. 분명히 "North"와 "SOUTH"는 반대이고 "WEST"와 "EAST"도 반대입니다.

// 한 방향으로 갔다가 바로 반대 방향으로 돌아오는 것은 불필요한 노력이다.
// 이곳은 험악한 날씨와 물이 많지 않은 서쪽이기 때문에, 에너지를 절약하는 것이 중요합니다. 그렇지 않으면 목이 말라서 죽을 수도 있습니다!

// 내가 어떻게 산속 사막을 스마트하게 건넜는지.
// 남성에게 주어진 지시사항은 다음과 같습니다(언어에 따라 다름).

// ["북쪽", "남쪽", "동쪽", "서쪽", "북쪽", "서쪽"]
// 아니면
// { "북쪽", "남쪽", "동쪽", "서쪽", "북쪽", "서쪽"};
// 아니면
// [북,남,남,동,서,북,서]
// "북쪽"으로 가는 것과 "남쪽"으로 가는 것은 합리적이지 않다는 것을 즉시 알 수 있습니다.
// 같은 장소에 머무르는 것이 좋습니다! 그래서 그 과제는 그 남자에게 계획의 간단한 버전을 주는 것이다. 이 경우 더 나은 계획은 다음과 같습니다.

// ["서쪽"]
// 아니면
// {"WEST"}
// 아니면
// [서쪽]
// 기타 예:
// ["North", "SOURH", "EAST", "WEST",에서 "North" + "SOURH" 방향은 북쪽으로 갔다가 바로 되돌아옵니다.

// 길은 [] [동쪽], [서쪽]이 되고, 지금은 "동쪽"과 "서쪽"이 서로를 섬멸하기 때문에 최종 결과는 [](클로주어에서는 0)입니다.

// "[North], "EAST", "WEST", "SOUT", "WEST", "North", "WEST", "SOUTH"는 정반대가 아니라 "EAST"와 "WEST"를 줄인 후 정반대가 되기 때문에 전체 경로가 "[WEST", "WEST"로 축소됩니다.

// 태스크
// 문자열 배열을 사용하고 불필요한 방향이 제거된 문자열 배열을 반환하는 dirReduck 함수를 작성합니다(W<->E 또는 S<->N 나란히).

// Haskell 버전은 방향 = 북쪽 | 동쪽 | 서쪽 | 남쪽 데이터를 사용하여 방향 목록을 표시합니다.
// 경로가 무로 줄어들면 Clojure 버전은 0을 반환합니다.
// Rust 버전은 enum Direction {North, East, West, South} 조각을 사용합니다.
// 자세한 예제는 "표본 검정:"을 참조하십시오.
// 메모들
// 모든 경로를 단순화할 수 있는 것은 아닙니다. 경로([] [North", "WEST", "SOUD", "EAST])는 축소할 수 없습니다.
// "North"와 "WEST", "WEST"와 "SOUTH", "SOUTH"는 서로 정반대가 아니므로 "EAST"가 될 수 없습니다. 따라서 결과 경로 자체는 [ [North", "WEST", "SOUT", "EAST]입니다.
// 번역하고 싶으면 번역하기 전에 물어보세요.
